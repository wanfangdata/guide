#Oracle数据库结构设计规范

[1.适用范围](#1适用范围)

[2.知识体系与参考文档](#2知识体系与参考文档)

[3.一般要求](#3一般要求)
* [3.1.理解需求，合理设计](#31理解需求，合理设计)
* [3.2.命名规范、一致](#32命名规范、一致)

[4.数据库结构设计规范](#4数据库结构设计规范)
* [4.1.数据库](#41数据库)
* [4.2.用户](#42用户)
* [4.3.表空间](#43表空间)
* [4.4.表空间数据文件](#44表空间数据文件)
* [4.5.序列](#45序列)
* [4.6.表](#46表)
* [4.7.索引](#47索引)
* [4.8.存储过程/函数/包](#48存储过程/函数/包)
* [4.9.约束](#49约束)
* [4.10.表分区](#410表分区)
* [4.11.同义词](#411同义词)
* [4.12.目录](#412目录)
* [4.13.视图](#413视图)
* [4.14.表结构变更](#414表结构变更)

[5.SQL脚本和存储过程开发规范](#4SQL脚本和存储过程开发规范)
* [5.1.PL/SQL编码规范](#51PL/SQL编码规范)
* [5.2.异常处理](#52异常处理)
* [5.3.批量处理过程监控](#53批量处理过程监控)
* [5.4.脚本编码格式](#54脚本编码格式)

[6.数据库设计范式](#6数据库设计范式)
* [6.1.简介](#61简介)
* [6.2.第一范式](#62第一范式)
* [6.3.第二范式](#63第二范式)
* [6.4.第三范式](#64第三范式)

## 1.适用范围
规范数据库逻辑模型与物理模型的设计，提高系统可维护性和可扩展性，避免性能问题。
适用对象与范围：本规范适用于数据库设计人员，要求设计人员理解关系数据库的基本概念，掌握Oracle数据库的基本开发技能。

## 2.知识体系与参考文档
开发设计人员应具备的知识体系：
* 数据库概念与体系结构
* 数据库逻辑与物理模型的设计方法
* 数据库开发技能
* 数据库应用优化技能
* 常见数据库系统故障分析方法

** 以Oracle数据库为例，包括但不限于如下文档：**
Oracle Database Administrator's Guide 11g Release 2
Oracle Database Concepts 11g Release 2 (11.2)
Oracle Database Performance Tuning Guide 11g Release 2 (11.2)
Oracle Database SQL Language Reference 11g Release 2 (11.2)
SQL*Plus User's Guide and Reference Release 11.2
Oracle Database VLDB and Partitioning Guide 11g Release 2 (11.2)

## 3.一般要求
良好的数据库结构设计在满足功能需求外，还应满足非功能需求，体现在系统的可维护性、扩展性，保证数据质量，消除系统性能瓶颈。
    
本文约定：
规则：应严格遵守
建议：根据以往经验总结，一般情况下应予遵守
关注：由于应用场景的特殊性，无法给出简单结论，设计时需要重点考虑的因素

### 3.1.理解需求，合理设计
深入理解需求，需要关注：
* 实体基本属性
* 实体关系
* 唯一性
* 列是否可空
* 数据量
* 数据清理逻辑
* 数据访问方式（INSERT/UPDATE/DELETE/SELECT分别以哪些列为条件进行查询）
* 数据访问频率（INSERT/UPDATE/DELETE/SELECT）
* 关联关系

### 3.2.命名规范、一致
系统内对象的命名应该规范、一致，包括但不限于以下对象：
* 表
* 列
* 索引
* 序列
* 存储过程/函数/包/触发器
* 约束
* 同义词
* 临时表
* 视图

## 4.数据库结构设计规范
### 4.1.数据库
全局数据库名和实例SID 名称保持一致。数据库结构设计工具建议使用PowerDesigner。

### 4.2.用户
每个数据库用户模式一般表示一个子系统，使用子系统英文描述索引进行命名。

### 4.3.表空间
表空间包括系统表空间和用户表空间，其中系统表空间不存放业务数据，只供数据库本身使用，用户表空间面向实际用户。存放真正的业务数据。

* 用户数据表空间：存放用户数据表，命名格式为用户名_DATA_内容缩写。
* 用户索引表空间：存放用户索引，命名格式为用户名_IDX_内容缩写。
* 用户临时表空间：存放用户临时创建的表，命名格式为用户名_TMP_内容缩写。

### 4.4.表空间数据文件
表空间对应多个数据文件。对使用裸设备文件的情况不适用。命名格式为：表空间名_两位数序序号 .dbf ，如USER_01.dbf表示USER表空间的第一个数据文件。

### 4.5.表空间数据文件
命名规则：
* 名称应准确反映业务含义
* 命名格式为SEQ_ABC

建议：
* Cache：根据并发量，设置cache（如100、1000、10000）
* Order：除非有特殊的业务需求，不应设置order属性

### 4.6.表
表命名规则：
* 表名称应简洁，准确反映表内数据的业务含义
* 交易表名称以TRANS_开头
* 日志表名称以_LOG结尾
* 临时表名称应以TMP开头，如TMP_ABC
* 备份表名称应以BAK开头，如BAK_ABC
* 不能使用系统保留字

列命名规则：
* 列名称应简洁，准确反映列内数据的业务含义
* 应参考已存在同样业务含义的列进行命名
* 不能使用系统保留字

表设计建议：
* 使用规范化设计避免冗余，通过反规范化设计提高性能，参考附录A
* 类型（堆表、索引组织表、集群表、外部表）
* 根据数据特征，设置存储属性（表空间、PCT_FREE、INITRANS等）
* 数据保留周期，历史数据清理逻辑
* 如表数据量超过100万，考虑进行表分区
* 除应用程序不访问的日志表外，均应创建主键

列类型选择建议：
* 应根据业务规则确定列类型
* 明确最大长度或精度，同样的列在不同表中类型、长度、精度应一致

针对LOB字段的设计建议：
* 一般假设LOB字段变化较少，读取次数少；基于此，LOB字段和常用字段存储在不同表中，或使用(disable storage in row),可以减少系统I/O
* 根据应用访问特点，可以利用Oracle11g中SecureFile中的压缩特性
 
注释规则：
* 表、字段都要有注释，说明业务含义
* 对于枚举型列，应在注释中列举。

### 4.7.索引
命名规则：
* 应包含表名、列名
* 唯一索引命名格式为UIDX_TABNAME_COL1
* 主键命名格式为PK_TABNAME_COL1
* 位图索引命名格式为BIDX_TABNAME_COL1

创建索引时，应考虑索引存储与维护成本，关注：
* 创建索引目的明确（实现唯一约束，加快查询、排序速度）
* 索引类型（B+树、位图、函数等）
* 在线交易系统（OLTP）慎用位图索引
* 根据数据特征，设置存储属性（表空间、PCT_FREE、INITRANS等）
* 外键列上应创建索引

复合索引需要慎重考虑列顺序，建议：
* 确定列顺序时，除了考虑查询条件外，还需考虑插入时索引块分裂的问题（比如时间+客户号复合索引中，如果以时间为前缀列，新插入的行总是在索引树的最右侧；如果修改为以客户号为前缀，那么插入的记录会分散在索引树的不同位置，大大缓解索引块分裂集中爆发问题）
* 如果前缀列distinct value不多，即使查询条件不包含前缀列，执行计划仍可能通过INDEX SKIP SCAN方式使用索引

存储参数PCTFREE设置建议：
* 对于经常被UPDATE且被update的列所占字节比较大的表，需要设置较大的PCTFREE，避免造成过多行迁移。
* 对于可能造成热点块的表，PCTFREE参数需要设置较大，尽量减少热点块发生概率。

### 4.8.存储过程/函数/包
命名规则：
* 函数命名以F_开头，后接函数的功能
* 存储过程以PRC_开头，后接功能描述
* 包以PKG_开头，后接功能描述
* 触发器名称格式，TRI_开头，后接功能描述

建议：
* 合理利用自治事务
* 合理利用调用者权限和使用者权限
* 避免存储过程之间存在复杂依赖关系
* 一般情况下，不得使用触发器

### 4.9.约束
命名规则：
* 应包含表名、列名
* 检查约束命名规则，CHK_TABNAME_COL1_COL2
* 主键应以PK_TABNAME
* 外键格式应为FK_TABNAME_COL1_R_TAB2

关注：
* 对于需要确保数据一致性的表，创建约束（非空、唯一、外键、检查）
* 针对外键约束，如果父表的记录需要修改或删除，子表必须创建索引，避免死锁
* 合理利用约束，提高数据质量

### 4.10.表分区
命名规则：
* 范围分区名称应为PYYYYMM或PYYYYMMDD（分别对应月分区和日分区），PMAX对应最大的分区
* 列表分区名称应为P_ABC（ABC对应分区内容），P_DEFAULT对应缺省的分区

关注：
* 明确分区目的（性能、历史数据管理、数据移动）
* 根据应用访问特点，选择合适的表分区类型（范围、HASH、列表、系统、引用及各种组合类型）
* 根据应用访问特点，选择索引为本地或全局
* 需要考虑分区维护机制（新增分区、删除历史分区、迁移历史分区等）
* 一般情况下，不允许修改分区键

确定索引为全局或本地，建议：
* 如无全局索引，针对表分区的drop/truncate无需维护全局索引，
* 如有全局索引，在针对表分区的维护操作，必须考虑全局索引的维护（索引状态、操作耗时等）

### 4.11.同义词
命名规则：
* 应创建与表相同名字的同义词

关注：
* 应创建私有同义词，除非有特殊考虑
* 同名对象访问顺序：schema内对象 > public 同义词

### 4.12.目录
建议：
* Directory使用权限赋予需要使用的数据库用户
* 对应的操作系统目录对oracle操作系统用户开放读写权限

### 4.13.视图
命名规则：V_表名 

规则：
* 应明确指定列，不应使用select * 方式定义视图
* 涉及多表时，需要使用表别名限定列所属表

### 4.14.表结构变更
表结构变更这里主要指增加列、删除列、调整类型，不包括存储属性的变更。

针对表结构变更，关注：
* 新增列是否有缺省值（如有缺省值，需要考虑投产窗口）
* 是否需要进行数据迁移
* 主键/索引是否需要调整
* 应用调整
* 对其他业务领域的影响（原则上要求不能影响其他业务条线）

## 5.SQL脚本和存储过程开发规范
### 5.1.PL/SQL编码规范
编码规则：
* 程序块应采用缩进风格书写，保证代码可读，风格一致，缩进格数统一为2格
* 代码中需要空位时，统一采用空格键输入，不允许用TAB键产生空位
* 相对独立的程序块之间应加空行
* 不允许把多个语句写在一行中，即一行只写一条语句
* 不使用goto 语句

注释规则：
* 在代码中进行必要的注释，以便后期维护
* 创建时，应在注释中说明创建内容，创建日期，以及创建责任人
* 更新时，应在注释中说明更新内容，更新日期，以及更新责任人

存储过程命名规则：
* 函数命名以F_开头，后接函数的功能
* 存储过程以PRC_开头，后接功能描述
* 包以PKG_开头，后接功能描述

变量使用规则：
* 存储过程、函数、触发器、程序块中定义的变量和输入、输出参数在命名上有所区分（如用v_开头代表程序块中定义的变量，用p_开头代表输入参数变量，用cur_开头代表游标变量）
* 变量类型与对应表一致，建议使用相关表字段的类型定义%type、%rowtype

### 5.2.异常处理
全面考虑各种可能异常（如各种约束导致的异常），并给予合理处理
各类异常应记录日志，以便故障分析

### 5.3.批量处理过程监控
对于批量处理中耗时较多的步骤，需要考虑进度监控方式，建议：
对于处理时间较长的PL/SQL，可以使用DBMS_APPLICATION_INFO更新进度，以便监控进度

### 5.4.脚本编码格式
如果脚本中只包含中英文字符，脚本编码使用GBK编码；运行时，环境变量使用NLS_LANG=.ZHS16GBK。
如果脚本中只包含除中英文外的其他字符，脚本编码使用UTF8编码；运行时，环境变量使用NLS_LANG=.AL32UTF8。

## 6.数据库设计范式
### 6.1.简介
为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。
关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、第四范式（4NF）、第五范式（BCNF）和第六范式（5NF）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。
设计关系型数据库时，遵从不同的规范要求，设计出合理的关系型数据库。这些规范被称作范式。越高的范式数据库的冗余度就越低。

### 6.2.第一范式
要求：无重复的列。
数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。如果实体中的某个属性有多个值时，必须拆分为不同的属性
在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。

### 6.3.第二范式
要求：属性完全依赖于主键。
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。
当存在多个列组成的主键时，才会发生不符合第二范式的情况。比如有两个列组成的主键，不能存在这样的属性，它只依赖于其中一个主键，这就是不符合第二范式。
如果存在不符合第二范式的情况，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。

### 6.4.第三范式
要求：属性不能传递依赖于主属性。
第三范式（3NF）是在第二范式（2NF）的基础上建立起来的，即满足第三范式（3NF）必须先满足第二范式（2NF）。
如果某一属性依赖于其他非主键属性，那么这个属性就是间接依赖于主键，这被称作传递依赖于主属性。
